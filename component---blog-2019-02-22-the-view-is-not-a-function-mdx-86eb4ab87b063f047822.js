(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{"/Ai1":function(e,t,a){"use strict";a.d(t,"a",(function(){return c}));a("Ll4R"),a("q1tI");var n=a("7ljp"),o=a("eC7B"),s=a("m8Tn"),i=a("8rN0"),r=a("qKvR"),l=/\/\/(?:.*\.)?([^.]+\.[^./]+)\//;function c(e){var t=e.children,a=e.pageContext,c=a.frontmatter.canonical;return Object(r.a)(s.a,a.frontmatter,Object(r.a)(n.a,{components:i},Object(r.a)(o.a,null,Object(r.a)(i.Container,null,Object(r.a)("h1",null,a.frontmatter.title),c&&Object(r.a)("p",{class:"small"},Object(r.a)("a",{href:c,target:"_blank",rel:"noopener noreferrer"},"This article was originally published"," ",function(e){var t=e.match(l);return t?"at "+t[1]:"here"}(c)," ⬈")),t))))}},"W/qr":function(e,t,a){"use strict";a.r(t),a.d(t,"_frontmatter",(function(){return i})),a.d(t,"default",(function(){return c}));a("E5k/"),a("rzGZ"),a("Dq+y"),a("8npG"),a("Ggvi"),a("q1tI");var n=a("7ljp"),o=a("/Ai1");a("qKvR");function s(){return(s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}var i={},r={_frontmatter:i},l=o.a;function c(e){var t=e.components,a=function(e,t){if(null==e)return{};var a,n,o={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,["components"]);return Object(n.b)(l,s({},r,a,{components:t,mdxType:"MDXLayout"}),Object(n.b)("p",null,"Previously I claimed that the view is a function, but I was wrong. Or was I?"),Object(n.b)("h2",null,"Views must have state"),Object(n.b)("p",null,"My first user interfaces were ",Object(n.b)("code",s({parentName:"p"},{className:"language-text"}),"PRINT “some text”"),". I have considered that it was stateless. It was not."),Object(n.b)("p",null,"When I was a child programming BASIC usually the first step before PRINT was “CLS,” clear the screen. The CLS command does something more than clearing the screen; it also resets the cursor position to the first line and first column. That it is because each PRINT shows the text in the cursor position, and it alters the cursor position. Two consecutive calls to PRINT with the same arguments printed the same thing in different locations. That means that PRINT is not a pure function, and there is a state."),Object(n.b)("p",null,"We display our views on the screen. The screen requires memory to store what it has to show. That memory is state. The same is valid for speakers — they have a memory buffer — , printers — they even have a pool of papers — , and any other physical device has state."),Object(n.b)("p",null,"Object-oriented programming views objective is to split those physical devices with large amounts of memory and state into smaller ones. Instead of having one screen, we have multiple windows, panels, labels, input texts, buttons and so on. And Object-oriented parading naturally fits, they reproduce what we already have with a more convenient abstraction and programming interface."),Object(n.b)("h2",null,"Our brain has state"),Object(n.b)("p",null,"And there is no clear button."),Object(n.b)("p",null,"That is the objective of any user interface, the view. We have to synchronize our application state with the brain of the user."),Object(n.b)("p",null,"That is nothing to be worried about, or it should be the only thing to be concerned. All creativity, methodologies, and philosophies come about how to synchronize both. Call it user experience or usability."),Object(n.b)("p",null,"But, what we cannot tolerate is to confuse the user. When we deal with multiple replicated state, showing the same data on many views, we must be sure that all views are consistent. That means synchronize all replicated states. And this is hard."),Object(n.b)("h2",null,"React is not stateless"),Object(n.b)("p",null,"The cornerstone of React is the render function: a pure function designed to compute the view. And those functions are meant to be stateless."),Object(n.b)("p",null,"Of course, React has state. React allows using classes as views, classes are object-oriented and have state. They even have a property literally called state which is a state. And now they have created something called useState hook, which is a way to add a state to a function component."),Object(n.b)("p",null,"All this component state is optional. It is useful in some cases to deal with any state present in the view, but not in our application. If you want to understand that better, I suggest reading about containers and components in redux, or about smart components and dumb components in other methodologies."),Object(n.b)("h2",null,"CLS; PRINT Sequence"),Object(n.b)("p",null,"There is a state in the view, but somehow I learned the skill of erasing it and redrawing everything again. That was a crude mechanism, but effective."),Object(n.b)("p",null,"React is more refined. It allows you to generate all the view tree like it was nothing printed before, then it compares the previous tree with the new one, and then it manipulates the underlying view to match the new tree. React does not erase everything and paint again because of speed and flickering."),Object(n.b)("h2",null,"Who cares about the state in the view?"),Object(n.b)("p",null,"If you are using an object-oriented view, you have to care. Or do you?"),Object(n.b)("p",null,"What if you were allowed to recreate the view each time that the application state changes, you would care about the view state? If you can forget about the state in the view, the main problem of the state synchronization disappears. If your view abstraction layer is so good that it makes the view state disappear, is it present?"),Object(n.b)("p",null,"Of course, views have and always will have a state, but we should avoid them. We have tools, and we have abstractions. Use them, forgot about the state, and embrace your view as a function."))}c.isMDXComponent=!0}}]);
//# sourceMappingURL=component---blog-2019-02-22-the-view-is-not-a-function-mdx-86eb4ab87b063f047822.js.map