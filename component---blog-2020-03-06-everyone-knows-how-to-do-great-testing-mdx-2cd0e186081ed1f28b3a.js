(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{"/Ai1":function(e,t,o){"use strict";o.d(t,"a",(function(){return l}));o("q1tI");var a=o("7ljp"),n=o("eC7B"),i=o("m8Tn"),s=o("8rN0"),r=o("qKvR"),h=/\/\/(?:.*\.)?([^.]+\.[^./]+)\//;function l(e){var t=e.children,o=e.pageContext,l=o.frontmatter.canonical;return Object(r.a)(i.a,o.frontmatter,Object(r.a)(a.a,{components:s},Object(r.a)(n.a,null,Object(r.a)(s.Container,null,Object(r.a)("h1",null,o.frontmatter.title),l&&Object(r.a)("p",{class:"small"},Object(r.a)("a",{href:l,target:"_blank",rel:"noopener noreferrer"},"This article was originally published"," ",function(e){var t=e.match(h);return t?"at "+t[1]:"here"}(l)," ⬈")),t))))}},NcxK:function(e,t,o){"use strict";o.r(t),o.d(t,"_frontmatter",(function(){return r})),o.d(t,"default",(function(){return u}));var a=o("wx14"),n=o("zLVn"),i=(o("q1tI"),o("7ljp")),s=o("/Ai1"),r=(o("qKvR"),{}),h={_frontmatter:r},l=s.a;function u(e){var t=e.components,o=Object(n.a)(e,["components"]);return Object(i.b)(l,Object(a.a)({},h,o,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"In the past, I thought that testing was hard, that you need considerable practice to learn to do proper testing. A few days ago, I realized that it is not correct; every programmer already knows how to test. In this article, I present a small recipe that allows anyone to write excellent tests starting today.")),Object(i.b)("h2",null,"First Hint"),Object(i.b)("p",null,"I learned the first hint from Uncle Bob just a few weeks ago. I was learning from one of their videos, and I heard the following question:"),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"» Which test you write first?")),Object(i.b)("p",null,"The question surprised me, because I have years of experience writing tests, and I had never asked the same question to myself. But Uncle Bob was right. But the answer that he gave to that question was also surprising and amazingly simple:"),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"» If you do not write tests, which code would you write first?")),Object(i.b)("p",null,"If you follow TDD (you should), there is a rule that says: you cannot write any production code until you have a failing test. And then, when you have that unit test failing, you cannot write more code than is sufficient to pass the test. That means that you cannot start writing production code; you need to write one test first. And which is that test? Simple, the one that gives you the excuse to write the code that you need."),Object(i.b)("p",null,"Do you not know where to begin to write a test? Write one that allows you to write the code that you need. That is simple. "),Object(i.b)("h2",null,"The Recipe"),Object(i.b)("p",null,"That was the first hint that I had: everyone knows how to write the first test. It is because everyone already has the skills to do it: every experienced programmer knows how to start coding, so everyone knows which is the first chunk of code, therefore, what to test first. "),Object(i.b)("p",null,"So, is it possible that everyone knows how to do good tests in any case? "),Object(i.b)("h3",null,"Step 1: First tests"),Object(i.b)("p",null,"We already have the recipe to make tests. It is to write first the tests that give us the excuse to write the code. Ok, you might find it slow in the beginning, but give yourself a little bit of practice. Embrace the TDD discipline and make the effort of writing the tests before. There is no better moment in a project to start learning proper testing."),Object(i.b)("h3",null,"Step 2: Scaling large code"),Object(i.b)("p",null,"What happens if you already have an extensive application, or you discover a bug? What happens if you do not have a broad base of tests to help you doing tests?"),Object(i.b)("p",null,"Here the tip of writing the test that gives you the excuse to write the code is not easy to follow. It seems so complicated, and it is far more straightforward to start the application and test by hand the latest changes that you have done. But this is also the answer. Because you know how to test the application manually, you know what you need to test (and what not to test). And that is what you have to write."),Object(i.b)("p",null,"We never write a large chunk of code at once; we all, almost all, avoid doing that. Instead, we write a small piece of code. Then, we open the application, navigate, introduce data, and finally, we evaluate if the chunk of code behaves correctly. And we iterate again until we finish a feature."),Object(i.b)("p",null,"That iterative is the precursor of TDD without testing. So, what we have to do? Easy, instead of test the application manually, we write the code that does the same operation us."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Are you doing login in your application? Consuming a service?")," Write a mock for the service. I have seen many times programmers hardcoding fake credentials to test their software manually. You can do it manually and risk to commit it, or, put a little effort abstracting that functionality so you can mock it quickly."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Are you navigating through the UI? Changing the view? Filling a form?")," Reproduce the same steps with your test. Make your test select the view in which the functionality works and fill the forms for you. It might seem hard if it is the first time that you do it, but if you do it manually, and you know the code, you know what precisely execute in the test to make your application reach the point."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Are you developing an API? No UI involved?")," I bet you that you are using Postman or a similar tool to test it manually. Do the same in your test. Use MockMCV, Supertest, or any tool available in your software stack. Do API calls directly from your test and read the result. And of course, Am I right when I say that you do not check that every field in the response is ok? Do not do that in your test, either. Instead of snapshotting, or similar, use tools like Jsonpath, check only the fields and values that are relevant for your test."),Object(i.b)("p",null,"Try to stick to your debugging skills all the time; we are wiser more experienced than we realize. Leverage on that knowledge and make your code do what you would do manually, no more, no less."),Object(i.b)("h3",null,"Step 3: Remove references to UI"),Object(i.b)("p",null,"That seems a little bit trickier because it does not feel natural in the beginning, but it is just the opposite. "),Object(i.b)("p",null,"The recipe in Step 2 says that you should reproduce what you do manually. And without doubt, you are using the UI. So, what means removing references to the UI?"),Object(i.b)("p",null,"A little self-reflection. What do you think when you interact with the UI? Do you think: I am going to click that field, type those keys, and push the search button? Or you think: I am going to do that search? The second one, right? That is what you have to do."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Instead of writing in the test direct calls to the UI, create a library or an interface to express what you think"),". Write a function call: search, instead of manipulating the UI. And then implement the exact behavior in the function. "),Object(i.b)("p",null,"Writing and using this abstraction library, you accomplish two objectives. The first is that the testing code is more readable than writing direct UI calls. It expresses the steps of the test at a level closer to your reasoning and probably closer to the requirements that you have. And second, you protect yourself from future changes in the UI. So you are not afraid of changes."),Object(i.b)("h3",null,"Step 4: Refactor"),Object(i.b)("p",null,"It is not refactor everything; it is just maintaining things easy to read. But the test code the most."),Object(i.b)("p",null,"Once you have written your firsts test, try to read them. Try to guess what their intention is and what they are trying to accomplish. A good test should be readable like prose. Experiment, create helper functions, artifacts, whatever you need, but make it readable. In the future, you will need to read it and understand it."),Object(i.b)("p",null,"There is no need to say that the testing code should be cleaner and easier to understand than the production code."),Object(i.b)("h3",null,"Step 5: Do not forget the business value"),Object(i.b)("p",null,"If you follow Step 2 (you should), you will notice that we end creating lots of tests for many little things. "),Object(i.b)("p",null,"When you test things manually, not everything that you test is what you have asked to implement; there are many small steps that we take to achieve that. And because you test them manually, you give no importance because any manual test that you do is destroyed when you finish. It is a matter of speaking; we do not destroy it; we simply do not repeat it."),Object(i.b)("p",null,"When we reproduce the same steps with automatic testing, we potentially end up with lots of tests. Once we write a test, it remains here, unless we remove it. That is ok. They are called stairstep tests. That means that they are tests that act like little steps that allow us to achieve our objective. Once we have achieved our objective, and we have a few useful tests, we can remove those old tests. Do not get very attached to them, give him thanks, and remove them."),Object(i.b)("p",null,"What is our objective? It is to implement some functionality. We have to implement a functionality that gives business value. Our test must show which is the functionality and how it works. We should be able to read, understand, and remember that from our test. Each test should reflect directly which business value it gives. "),Object(i.b)("h3",null,"Extra Step: Use tables"),Object(i.b)("p",null,"Almost all testing frameworks accepts tables. They are handy. Learn their API and use them."),Object(i.b)("p",null,"Why are they so handy? Because when you have one code that tests one case, you can add more cases by adding rows in a table. With just one testing code, you can handle tens of cases. They are easier to maintain and to read that maintain. Do not doubt to refactor your test to accommodate as many tables as they make sense."),Object(i.b)("h2",null,"Conclusion"),Object(i.b)("p",null,"Do great testing is just a matter of introspection. Learn how you test things manually, why you follow some steps, and no others. Then, automatize them."),Object(i.b)("p",null,"Make the testing code work for you."))}u.isMDXComponent=!0}}]);
//# sourceMappingURL=component---blog-2020-03-06-everyone-knows-how-to-do-great-testing-mdx-2cd0e186081ed1f28b3a.js.map